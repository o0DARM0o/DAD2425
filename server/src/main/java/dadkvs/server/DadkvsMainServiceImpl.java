package dadkvs.server;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import dadkvs.DadkvsPaxos;
import dadkvs.DadkvsPaxosServiceGrpc;
import dadkvs.util.DebugMode;
import dadkvs.util.PaxosManager;
import io.grpc.ManagedChannel;
import io.grpc.stub.StreamObserver;

	public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

	DadkvsServerState server_state;
	int               timestamp;
	int               sequenceCounter = 0;
	PaxosManager      paxosManager;
	int               paxosIndex;

	private final Object freezeLock = new Object(); // Lock object for freeze/unfreeze mechanism

	public DadkvsMainServiceImpl(DadkvsServerState state, PaxosManager paxosManager) {
		this.server_state = state;
		server_state.mainServiceImpl = this;
		this.timestamp = 0;
		this.paxosManager = paxosManager;
		this.paxosIndex = 0;
	}

	private void checkFreeze() {
		synchronized (freezeLock) {
			while (server_state.new_debug_mode == DebugMode.FREEZE) {
				try {
					System.out.println("Server is in FREEZE mode. Pausing request handling...");
					freezeLock.wait(); // Wait until UN_FREEZE is called
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt(); // Reset thread interrupt status
				}
			}
		}
	}

	private void unfreeze() {
		synchronized (freezeLock) {
			System.out.println("Server is in UN_FREEZE mode. Resuming request handling...");
			freezeLock.notifyAll(); // Notify all waiting threads
		}
	}

	@Override
	public void read(DadkvsMain.ReadRequest request,
			StreamObserver<DadkvsMain.ReadReply> responseObserver) {

	checkFreeze(); // Check if server is frozen before processing the request
	// for debug purposes
	System.out.println("Receiving read request:" + request);

	int reqid = request.getReqid();
	int key = request.getKey();
	VersionedValue vv = this.server_state.store.read(key);
	
	DadkvsMain.ReadReply response =DadkvsMain.ReadReply.newBuilder()
		.setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();

	responseObserver.onNext(response);
	responseObserver.onCompleted();
	}

	@Override
	public void committx(DadkvsMain.CommitRequest request,
			StreamObserver<DadkvsMain.CommitReply> responseObserver) {

		checkFreeze(); // Check if server is frozen before processing the request
	
		System.out.println("Receiving commit request: " + request);
	
		int proposedIndex = getProposedIndex();
		int key = request.getWritekey();
	
		if (!isIndexValid(proposedIndex)) {
			rejectCommit(responseObserver, request, proposedIndex);
			return;
		}
	
		preparePaxos(proposedIndex, key, request.getWriteval());
	
		if (server_state.i_am_leader) {
			handleLeaderRole(proposedIndex, request, responseObserver);
		} else {
			System.out.println("Rejecting commit request: Not the leader.");
		}
	}


	// committx helper functions below
	
	// Generate a new proposed index for this Paxos instance
	private int getProposedIndex() {
		return ++sequenceCounter;
	}
	
	// Check if the proposed index is valid (i.e., greater than the promised index)
	private boolean isIndexValid(int proposedIndex) {
		return proposedIndex > server_state.promisedIndex;
	}
	
	// Handle rejection of a commit request due to invalid index
	private void rejectCommit(StreamObserver<DadkvsMain.CommitReply> responseObserver,
			DadkvsMain.CommitRequest request, int proposedIndex) {

		System.out.println(
				"Rejecting commit request: proposed index " +
				proposedIndex + " is not greater than promised index " +
				server_state.promisedIndex
		);

		DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
			.setReqid(request.getReqid())
			.setAck(false) // Reject
			.build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}
	
	// Prepare Paxos for a new transaction by starting a new instance
	private void preparePaxos(int proposedIndex, int key, int writeVal) {

		this.paxosIndex = proposedIndex;
		int proposalTimestamp = this.timestamp + 1;

		System.out.println(
				"Starting Paxos instance for proposed index: " +
				proposedIndex + " with timestamp: " +
				proposalTimestamp
		);

		paxosManager.startPaxosInstance(proposedIndex, key, proposalTimestamp, writeVal);
	}
	
	// Handle the role of the leader during Paxos phases
	private void handleLeaderRole(int proposedIndex, DadkvsMain.CommitRequest request,
			StreamObserver<DadkvsMain.CommitReply> responseObserver) {

		int majority = (server_state.n_servers / 2) + 1;
	
		// Phase 1: Prepare
		if (performPhaseOne(proposedIndex, majority)) {
			// Phase 2: Accept
			if (performPhaseTwo(proposedIndex, request.getWriteval(), majority)) {
				// Commit and learn
				processAndCommitTransaction(proposedIndex, request, responseObserver, majority);
			} else {
				sendRejection(responseObserver, request,
						"Phase 2 not accepted by majority.");
			}
		} else {
			sendRejection(responseObserver, request, "Phase 1 not accepted by majority.");
		}
	}
	
	// Perform Phase 1 of Paxos protocol (Prepare phase)
	private boolean performPhaseOne(int proposedIndex, int majority) {

		System.out.println("Leader assigned Paxos Instance number: " + proposedIndex);
		DadkvsPaxos.PhaseOneRequest phaseOneRequest = createPhaseOneRequest(proposedIndex);
	
		int acceptCount = 1;
		int rejectCount = 0;
	
		for (ManagedChannel channel : server_state.followerChannels) {

			DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stub =
					DadkvsPaxosServiceGrpc.newBlockingStub(channel);

			try {
				if (stub.phaseone(phaseOneRequest).getPhase1Accepted()) {
					System.out.println("Follower accepted Phase 1 for index: " + proposedIndex);
					acceptCount++;
				} else {
					rejectCount++;
				}
			} catch (Exception e) {
				System.err.println("Error during Phase 1 request: " + e.getMessage());
				rejectCount++;
			}
		}
	
		return acceptCount >= majority;
	}
	
	// Create Phase 1 request for Paxos protocol
	private DadkvsPaxos.PhaseOneRequest createPhaseOneRequest(int proposedIndex) {
		int proposalTimestamp = this.timestamp + 1;
		return DadkvsPaxos.PhaseOneRequest.newBuilder()
			.setPhase1Config(0)
			.setPhase1Index(proposedIndex)
			.setPhase1Timestamp(proposalTimestamp)
			.build();
	}
	
	// Perform Phase 2 of Paxos protocol (Accept phase)
	private boolean performPhaseTwo(int proposedIndex, int writeVal, int majority) {

		System.out.println("Proceeding to Phase 2 for index: " + proposedIndex);

		DadkvsPaxos.PhaseTwoRequest phaseTwoRequest =
				createPhaseTwoRequest(proposedIndex, writeVal);
	
		int acceptCount = 1;
		int rejectCount = 0;
	
		for (ManagedChannel channel : server_state.followerChannels) {

			DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stub =
					DadkvsPaxosServiceGrpc.newBlockingStub(channel);

			try {
				if (stub.phasetwo(phaseTwoRequest).getPhase2Accepted()) {
					System.out.println("Follower accepted Phase 2 for index: " + proposedIndex);
					acceptCount++;
				} else {
					rejectCount++;
				}
			} catch (Exception e) {
				System.err.println("Error during Phase 2 request: " + e.getMessage());
				rejectCount++;
			}
		}
	
		return acceptCount >= majority;
	}

	// Perform Phase 2 of Paxos protocol (Accept phase)
	private boolean performCommitPhase(DadkvsMain.CommitRequest request, int majority) {

		int acceptCountCommit = 1; // Include leader
		int rejectCountCommit = 0;

		for (ManagedChannel channel : server_state.followerChannels) {

			DadkvsMainServiceGrpc.DadkvsMainServiceBlockingStub stub =
					DadkvsMainServiceGrpc.newBlockingStub(channel);

			DadkvsMain.SequenceAck ack;
			try {
				ack = stub.sequenceCommit(request);
				if (ack.getAccepted()) {
					acceptCountCommit++;
				} else {
					rejectCountCommit++;
				}
			} catch (Exception e) {
				System.err.println(
						"Error during commit request to follower: " + e.getMessage());

				rejectCountCommit++;
			}
		}

		return acceptCountCommit >= majority;
	}
	
	// Create Phase 2 request for Paxos protocol
	private DadkvsPaxos.PhaseTwoRequest createPhaseTwoRequest(int proposedIndex, int writeVal) {
		int proposalTimestamp = this.timestamp + 1;
		return DadkvsPaxos.PhaseTwoRequest.newBuilder()
			.setPhase2Config(0)
			.setPhase2Index(proposedIndex)
			.setPhase2Value(writeVal)
			.setPhase2Timestamp(proposalTimestamp)
			.build();
	}
	
	// Process commit and send learn request to followers
	private void processAndCommitTransaction(int proposedIndex, DadkvsMain.CommitRequest request,
			StreamObserver<DadkvsMain.CommitReply> responseObserver, int majority) {

		System.out.println("Majority accepted Phase 2. Proceeding to learning.");
	
		sendLearnRequests(proposedIndex, request.getWriteval());
	
		if (processCommit(request) && performCommitPhase(request, majority)) {
			System.out.println("Transaction committed.");
			sendCommitResponse(responseObserver, request, true);
		} else {
			sendRejection(responseObserver, request, "Commit not accepted by majority.");
		}
	}
	
	// Send learn requests to followers after Phase 2
	private void sendLearnRequests(int proposedIndex, int writeVal) {
		DadkvsPaxos.LearnRequest learnRequest = createLearnRequest(proposedIndex, writeVal);
	
		for (ManagedChannel channel : server_state.followerChannels) {

			DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stub =
					DadkvsPaxosServiceGrpc.newBlockingStub(channel);

			try {
				stub.learn(learnRequest);
				System.out.println("Sent learn request to follower for index: " + proposedIndex);
			} catch (Exception e) {
				System.err.println("Error during learn request: " + e.getMessage());
			}
		}
	}
	
	// Create learn request for Paxos protocol
	private DadkvsPaxos.LearnRequest createLearnRequest(int proposedIndex, int writeVal) {
		return DadkvsPaxos.LearnRequest.newBuilder()
			.setLearnconfig(0)
			.setLearnindex(proposedIndex)
			.setLearntimestamp(this.timestamp + 1)
			.setLearnvalue(writeVal)
			.build();
	}
	
	// Send the final commit response to the client
	private void sendCommitResponse(StreamObserver<DadkvsMain.CommitReply> responseObserver,
			DadkvsMain.CommitRequest request, boolean result) {

		DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
			.setReqid(request.getReqid())
			.setAck(result)
			.build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}
	
	// Send rejection response to the client
	private void sendRejection(StreamObserver<DadkvsMain.CommitReply> responseObserver,
			DadkvsMain.CommitRequest request, String reason) {

		System.out.println("Rejecting commit request: " + reason);
		DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
			.setReqid(request.getReqid())
			.setAck(false) // Reject
			.build();
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	// Follower processes the sequenced request sent by the leader
	@Override
	public void sequenceCommit(DadkvsMain.CommitRequest request,
			StreamObserver<DadkvsMain.SequenceAck> responseObserver) {

		checkFreeze();
		
		//System.out.println("Follower received sequence request: " + request.getSequenceNumber());

		// Process the commit request (assume it is accepted for simplicity)
		boolean accepted = processCommit(request); // Apply the commit in sequence

		// Respond to the leader with an acknowledgment
		DadkvsMain.SequenceAck ack = DadkvsMain.SequenceAck.newBuilder()
				.setSequenceNumber(this.paxosIndex)
				.setAccepted(accepted)
				.build();

		responseObserver.onNext(ack);
		responseObserver.onCompleted();
	}

	/**
	 * Helper function to process commit requests. This function is used by both the leader and followers.
	 * 
	 * @param request CommitRequest containing the transaction information
	 * @return boolean indicating whether the commit was successful or not
	 */
	private boolean processCommit(DadkvsMain.CommitRequest request) {
		checkFreeze();
		
		int key1 = request.getKey1();
		int version1 = request.getVersion1();
		int key2 = request.getKey2();
		int version2 = request.getVersion2();
		int writekey = request.getWritekey();
		int writeval = request.getWriteval();

		// Increment timestamp for the commit
		this.timestamp++;

		// Create a transaction record with the provided information
		TransactionRecord txrecord = new TransactionRecord(
				key1,
				version1,
				key2,
				version2,
				writekey,
				writeval,
				this.timestamp
			);

		// Attempt to commit the transaction in the key-value store
		return this.server_state.store.commit(txrecord);
	}

	// End of committx helper functions


	// Add an override for `executeDebugMode` to handle unfreezing
	public void executeDebugMode(DebugMode debugMode) {
		if (debugMode == DebugMode.UN_FREEZE) {
			unfreeze(); // Call unfreeze when the mode is set to UN_FREEZE
		}
	}
}
