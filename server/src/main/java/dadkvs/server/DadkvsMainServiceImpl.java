package dadkvs.server;

import java.util.concurrent.atomic.AtomicInteger;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import dadkvs.DadkvsPaxos;
import dadkvs.DadkvsPaxosServiceGrpc;
import dadkvs.util.PaxosManager;
import io.grpc.ManagedChannel;
import io.grpc.stub.StreamObserver;

public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

    DadkvsServerState server_state;
    int               timestamp;
	AtomicInteger sequenceCounter = new AtomicInteger(0);
    PaxosManager paxosManager;
    int paxosIndex;
    
    public DadkvsMainServiceImpl(DadkvsServerState state, PaxosManager paxosManager) {
        this.server_state = state;
	    this.timestamp = 0;
        this.paxosManager = paxosManager;
        this.paxosIndex = 0;
    }

    @Override
    public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {
	// for debug purposes
	System.out.println("Receiving read request:" + request);

	int reqid = request.getReqid();
	int key = request.getKey();
	VersionedValue vv = this.server_state.store.read(key);
	
	DadkvsMain.ReadReply response =DadkvsMain.ReadReply.newBuilder()
	    .setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();
	
	responseObserver.onNext(response);
	responseObserver.onCompleted();
    }

    @Override
    public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {
        System.out.println("Receiving commit request: " + request);
        
        int proposedIndex = sequenceCounter.incrementAndGet();;
        int key = request.getWritekey();
    
        // Check if the proposed index is less than or equal to the promised index
        if (proposedIndex <= server_state.promisedIndex) {
            System.out.println("Rejecting commit request: proposed index " + proposedIndex + " is not greater than promised index " + server_state.promisedIndex);
            DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
                .setReqid(request.getReqid())
                .setAck(false) // Reject
                .build();
            responseObserver.onNext(response);
            responseObserver.onCompleted();
            return;
        }
    
        this.paxosIndex = proposedIndex; 
        int proposalTimestamp = this.timestamp + 1;
        System.out.println("Starting Paxos instance for proposed index: " + proposedIndex + " with timestamp: " + proposalTimestamp);
    
        paxosManager.startPaxosInstance(proposedIndex, key, proposalTimestamp, request.getWriteval());
    
        if (server_state.i_am_leader) {
            System.out.println("Leader assigned Paxos Instance number: " + proposedIndex);
            DadkvsPaxos.PhaseOneRequest phaseOneRequest = DadkvsPaxos.PhaseOneRequest.newBuilder()
                .setPhase1Config(0)
                .setPhase1Index(proposedIndex)
                .setPhase1Timestamp(proposalTimestamp)
                .build();
    
            boolean allAcceptedPhase1 = true;
            for (ManagedChannel channel : server_state.followerChannels) {
                DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stub = DadkvsPaxosServiceGrpc.newBlockingStub(channel);
                DadkvsPaxos.PhaseOneReply ack = stub.phaseone(phaseOneRequest);
    
                if (!ack.getPhase1Accepted()) {
                    System.out.println("Follower rejected Phase 1 for index: " + proposedIndex);
                    allAcceptedPhase1 = false; // If any follower rejects, abort
                } else {
                    System.out.println("Follower accepted Phase 1 for index: " + proposedIndex);
                }
            }
    
            // Proceed only if all Phase 1 were accepted
            if (allAcceptedPhase1) {
                server_state.promisedIndex = proposedIndex;
                System.out.println("All followers accepted Phase 1. Proceeding to Phase 2.");
    
                DadkvsPaxos.PhaseTwoRequest phaseTwoRequest = DadkvsPaxos.PhaseTwoRequest.newBuilder()
                    .setPhase2Config(0)
                    .setPhase2Index(proposedIndex)
                    .setPhase2Value(request.getWriteval())
                    .setPhase2Timestamp(proposalTimestamp)
                    .build();
    
                boolean allAcceptedPhase2 = true;
                for (ManagedChannel channel : server_state.followerChannels) {
                    DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stub = DadkvsPaxosServiceGrpc.newBlockingStub(channel);
                    DadkvsPaxos.PhaseTwoReply ack = stub.phasetwo(phaseTwoRequest);
    
                    if (!ack.getPhase2Accepted()) {
                        System.out.println("Follower rejected Phase 2 for index: " + proposedIndex);
                        allAcceptedPhase2 = false;
                    } else {
                        System.out.println("Follower accepted Phase 2 for index: " + proposedIndex);
                    }
                }
    
                // Only proceed if all Phase 2 were accepted
                if (allAcceptedPhase2) {
                    System.out.println("All followers accepted Phase 2. Proceeding to learning.");
    
                    DadkvsPaxos.LearnRequest learnRequest = DadkvsPaxos.LearnRequest.newBuilder()
                        .setLearnconfig(0)
                        .setLearnindex(proposedIndex)
                        .setLearntimestamp(proposalTimestamp)
                        .setLearnvalue(request.getWriteval())
                        .build();
    
                    boolean allAcceptedLearn = true;
                    for (ManagedChannel channel : server_state.followerChannels) {
                        DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stub = DadkvsPaxosServiceGrpc.newBlockingStub(channel);
                        DadkvsPaxos.LearnReply ack = stub.learn(learnRequest);
    
                        if (!ack.getLearnaccepted()) {
                            System.out.println("Follower rejected Learn for index: " + proposedIndex);
                            allAcceptedLearn = false;
                        } else {
                            System.out.println("Follower accepted Learn for index: " + proposedIndex);
                        }
                    }
    
                    if (allAcceptedLearn) {
                        boolean allAccepted = true;
                        for (ManagedChannel channel : server_state.followerChannels) {
                            DadkvsMainServiceGrpc.DadkvsMainServiceBlockingStub stub = DadkvsMainServiceGrpc.newBlockingStub(channel);
                            DadkvsMain.SequenceAck ack = stub.sequenceCommit(request);

                            if(!ack.getAccepted()) {
                                allAccepted = false;
                            }
                        }

                        if(allAccepted ) {
                            boolean result = processCommit(request);
                            DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
                            .setReqid(request.getReqid()).setAck(result).build();

                            responseObserver.onNext(response);
                            responseObserver.onCompleted();
                        } else {
                            System.out.println("Rejecting commit request: Learning not accepted.");
                            sendRejection(responseObserver, request);
                        }
                    } else {
                        // If learning was not accepted
                        System.out.println("Rejecting commit request: Learning not accepted.");
                        sendRejection(responseObserver, request);
                    }
                } else {
                    // If Phase 2 was not accepted
                    System.out.println("Rejecting commit request: Phase 2 not accepted.");
                    sendRejection(responseObserver, request);
                }
            } else {
                // If Phase 1 was not accepted
                System.out.println("Rejecting commit request: Phase 1 not accepted.");
                sendRejection(responseObserver, request);
            }
        }
    }
    
    private void sendRejection(StreamObserver<DadkvsMain.CommitReply> responseObserver, DadkvsMain.CommitRequest request) {
        DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
            .setReqid(request.getReqid())
            .setAck(false) // Rejeita
            .build();
    
        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void sequenceCommit(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.SequenceAck> responseObserver) {        // Follower processes the sequenced request sent by the leader
        //System.out.println("Follower received sequence request: " + request.getSequenceNumber());

        // Process the commit request (assume it is accepted for simplicity)
        boolean accepted = processCommit(request); // Apply the commit in sequence

        // Respond to the leader with an acknowledgment
        DadkvsMain.SequenceAck ack = DadkvsMain.SequenceAck.newBuilder()
                .setSequenceNumber(this.paxosIndex)
                .setAccepted(accepted)
                .build();

        responseObserver.onNext(ack);
        responseObserver.onCompleted();
    }

    /**
     * Helper function to process commit requests. This function is used by both the leader and followers.
     * 
     * @param request CommitRequest containing the transaction information
     * @return boolean indicating whether the commit was successful or not
     */
    private boolean processCommit(DadkvsMain.CommitRequest request) {
        int key1 = request.getKey1();
        int version1 = request.getVersion1();
        int key2 = request.getKey2();
        int version2 = request.getVersion2();
        int writekey = request.getWritekey();
        int writeval = request.getWriteval();

        // Increment timestamp for the commit
        this.timestamp++;

        // Create a transaction record with the provided information
        TransactionRecord txrecord = new TransactionRecord(key1, version1, key2, version2, writekey, writeval, this.timestamp);

        // Attempt to commit the transaction in the key-value store
        return this.server_state.store.commit(txrecord);
    }
}
 