package dadkvs.server;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import dadkvs.DadkvsPaxos;
import dadkvs.DadkvsPaxosServiceGrpc;
import dadkvs.util.CollectorStreamObserver;
import dadkvs.util.DebugMode;
import dadkvs.util.GenericResponseCollector;
import dadkvs.util.PhaseOneCollectorStreamObserver;
import io.grpc.ManagedChannel;
import io.grpc.stub.StreamObserver;

	public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

	DadkvsServerState server_state;
	int               timestamp;
	int               sequenceCounter = 0;
	PaxosManager      paxosManager;
	int               paxosIndex;
    int               currentTimestamp = 0;
    //DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stubs[];
    

	private final Object freezeLock = new Object(); // Lock object for freeze/unfreeze mechanism

	public DadkvsMainServiceImpl(DadkvsServerState state, PaxosManager paxosManager) {
		this.server_state = state;
		server_state.mainServiceImpl = this;
		this.timestamp = 0;
		this.paxosManager = paxosManager;
		this.paxosIndex = 0;
		paxosManager.setService_impl(this);
	}

	private void checkFreeze() {
		synchronized (freezeLock) {
			while (server_state.new_debug_mode == DebugMode.FREEZE) {
				try {
					System.out.println("Server is in FREEZE mode. Pausing request handling...");
					freezeLock.wait(); // Wait until UN_FREEZE is called
				} catch (InterruptedException e) {
					Thread.currentThread().interrupt(); // Reset thread interrupt status
				}
			}
		}
	}

	private void unfreeze() {
		synchronized (freezeLock) {
			System.out.println("Server is in UN_FREEZE mode. Resuming request handling...");
			freezeLock.notifyAll(); // Notify all waiting threads
		}
	}

	@Override
	public void read(DadkvsMain.ReadRequest request,
			StreamObserver<DadkvsMain.ReadReply> responseObserver) {

	checkFreeze(); // Check if server is frozen before processing the request
	// for debug purposes
	System.out.println("Receiving read request:" + request);

	int reqid = request.getReqid();
	int key = request.getKey();
	VersionedValue vv = this.server_state.store.read(key);
	
	DadkvsMain.ReadReply response =DadkvsMain.ReadReply.newBuilder()
		.setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();

	responseObserver.onNext(response);
	responseObserver.onCompleted();
	}

	@Override
	public void committx(DadkvsMain.CommitRequest request,
			StreamObserver<DadkvsMain.CommitReply> responseObserver) {

		checkFreeze(); // Check if server is frozen before processing the request
	
		System.out.println("Receiving commit request: " + request);
	
		int proposedIndex = getProposedIndex();
		int key = request.getWritekey();
	
		/*if (!isIndexValid(proposedIndex)) {
			rejectCommit(responseObserver, request, proposedIndex);
			return;

		}*/
	
		preparePaxos(proposedIndex, key, request.getWriteval());
		paxosManager.getPaxosInstance(proposedIndex).setRequest(request);
		paxosManager.getPaxosInstance(proposedIndex).setObserver(responseObserver);
	
		// if (server_state.i_am_leader) {
		// 	handleLeaderRole(proposedIndex, request, responseObserver);
		// } else {
		// 	System.out.println("Rejecting commit request: Not the leader.");
		// }
	}


	// committx helper functions below
	
	// Generate a new proposed index for this Paxos instance
	private int getProposedIndex() {
		return ++sequenceCounter;
	}
	
	// Check if the proposed index is valid (i.e., greater than the promised index)
	private boolean isIndexValid(int proposedIndex) {
		return proposedIndex > server_state.promisedTimestap;
	}
	
	// Handle rejection of a commit request due to invalid index
	private void rejectCommit(StreamObserver<DadkvsMain.CommitReply> responseObserver,
			DadkvsMain.CommitRequest request, int proposedIndex) {

		System.out.println(
				"Rejecting commit request: proposed index " +
				proposedIndex + " is not greater than promised index " +
				server_state.promisedTimestap
		);

		DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
			.setReqid(request.getReqid())
			.setAck(false) // Reject
			.build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}
	
	// Prepare Paxos for a new transaction by starting a new instance
	private void preparePaxos(int proposedIndex, int key, int writeVal) {

		this.paxosIndex = proposedIndex;
		int proposalTimestamp = this.timestamp + 1;

		System.out.println(
				"Preparing Paxos instance for proposed index: " +
				proposedIndex + " with timestamp: " +
				proposalTimestamp
		);

		paxosManager.startPaxosInstance(proposedIndex, key, proposalTimestamp, writeVal);
		paxosManager.getPaxosInstance(proposedIndex).setIndex(proposedIndex);
	}
	
	// Handle the role of the leader during Paxos phases
	public void handleLeaderRole(int proposedIndex, DadkvsMain.CommitRequest request,
			StreamObserver<DadkvsMain.CommitReply> responseObserver) {

		int majority = (server_state.n_servers / 2) + 1;
        List<ManagedChannel> acceptingChannels = new ArrayList<>();
		// Phase 1: Prepare
        acceptingChannels = performPhaseOne(proposedIndex, majority);
		if (acceptingChannels.size() != 0) {
			// Phase 2: Accept
			if (performPhaseTwo(proposedIndex, request.getWriteval(), majority, acceptingChannels)) {
				// Commit and learn
				processAndCommitTransaction(proposedIndex, request, responseObserver, majority, this.currentTimestamp, acceptingChannels);
			} else {
				sendRejection(responseObserver, request,
						"Phase 2 not accepted by majority.");
			}
		} else {
			sendRejection(responseObserver, request, "Phase 1 not accepted by majority.");
		}
	}
	
	private List<ManagedChannel> performPhaseOne(int proposedIndex, int majority) {

        System.out.println("Leader assigned Paxos Instance number: " + proposedIndex);
        DadkvsPaxos.PhaseOneRequest phaseOneRequest = createPhaseOneRequest(proposedIndex);

        int counting = 0;

        List<ManagedChannel> acceptingChannels = new ArrayList<>(); // Track the servers that accept
        acceptingChannels.add(null); // Add leader to the list for simplicity

        ArrayList<DadkvsPaxos.PhaseOneReply> phaseOne_responses = new ArrayList<DadkvsPaxos.PhaseOneReply>();
	    GenericResponseCollector<DadkvsPaxos.PhaseOneReply> phaseOne_collector = new GenericResponseCollector<DadkvsPaxos.PhaseOneReply> (phaseOne_responses, server_state.n_servers);

        for (int i = 0; i < majority - 1; i++) { 
            ManagedChannel channel = server_state.followerChannels.get(i);
            PhaseOneCollectorStreamObserver phaseOne_observer = new PhaseOneCollectorStreamObserver(majority, phaseOne_collector);

            DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub stub =
                    DadkvsPaxosServiceGrpc.newStub(channel);

            try{
                stub.phaseone(phaseOneRequest, phaseOne_observer);
                acceptingChannels.add(channel);
            } catch (Exception e) {
                     System.err.println("Error during Phase 1 request: " + e.getMessage());
            }

        }

        phaseOne_collector.waitForTarget(majority - 1);
        if(phaseOne_responses.size() >= majority - 1) {
            Iterator<DadkvsPaxos.PhaseOneReply> pahseOne_iterator = phaseOne_responses.iterator();
            while (pahseOne_iterator.hasNext()) {
                DadkvsPaxos.PhaseOneReply phaseOne_reply = pahseOne_iterator.next ();
                if(phaseOne_reply.getPhase1Accepted()) {
                    //return acceptingChannels;
                    counting++;
                }
                
            }
            if(counting == majority -1) {
                return acceptingChannels;
            } else {
                acceptingChannels.removeAll(acceptingChannels);
                performPhaseOne(proposedIndex, majority);
            }
        }

        // If majority wasn't reached, return an empty list (indicating failure)
        return new ArrayList<>();
    }
	
	// Create Phase 1 request for Paxos protocol
	private DadkvsPaxos.PhaseOneRequest createPhaseOneRequest(int proposedIndex) {
		int proposalTimestamp = ++this.timestamp;
        currentTimestamp = proposalTimestamp;
        System.out.println("AQUIIIIII " + currentTimestamp);
		return DadkvsPaxos.PhaseOneRequest.newBuilder()
			.setPhase1Config(0)
			.setPhase1Index(proposedIndex)
			.setPhase1Timestamp(proposalTimestamp)
			.build();
	}
	
	// Perform Phase 2 of Paxos protocol (Accept phase)
	private boolean performPhaseTwo(int proposedIndex, int writeVal, int majority, List<ManagedChannel> acceptingChannels) {

		System.out.println("Proceeding to Phase 2 for index: " + proposedIndex);

        int counting = 0;
        boolean result = false;

		DadkvsPaxos.PhaseTwoRequest phaseTwoRequest =
				createPhaseTwoRequest(proposedIndex, writeVal);
	

        ArrayList<DadkvsPaxos.PhaseTwoReply> phaseTwo_responses = new ArrayList<DadkvsPaxos.PhaseTwoReply>();
	    GenericResponseCollector<DadkvsPaxos.PhaseTwoReply> phaseTwo_collector = new GenericResponseCollector<DadkvsPaxos.PhaseTwoReply> (phaseTwo_responses, server_state.n_servers);

	
		for (ManagedChannel channel : acceptingChannels) {
            CollectorStreamObserver<DadkvsPaxos.PhaseTwoReply> phaseTwo_observer = new CollectorStreamObserver<>(phaseTwo_collector);

            if (channel == null) {
                System.err.println("Found a null channel in acceptingChannels.");
               
            } else {
   
                DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub stub =
                DadkvsPaxosServiceGrpc.newStub(channel);

                try {
                    stub.phasetwo(phaseTwoRequest, phaseTwo_observer);
                    // System.out.println("Follower accepted Phase 2 for index: " + proposedIndex);

                } catch (Exception e) {
                    System.err.println("Error during Phase 2 request: " + e.getMessage());
                }
                
            }
		}

        phaseTwo_collector.waitForTarget(acceptingChannels.size()-1);
        if(phaseTwo_responses.size() >= acceptingChannels.size()-1) {
            Iterator<DadkvsPaxos.PhaseTwoReply> phaseTwo_iterator = phaseTwo_responses.iterator();
            while(phaseTwo_iterator.hasNext()) {
                DadkvsPaxos.PhaseTwoReply phaseTwo_reply = phaseTwo_iterator.next ();
                if(phaseTwo_reply.getPhase2Accepted()) {
                    counting++;
                } // verificar se j√° tem alguma coisa aceite

            }
            if(counting == acceptingChannels.size()-1) {
                result = true;
            } else {
                boolean procide = false;
                while (!procide) {
                    acceptingChannels.removeAll(acceptingChannels);
                    performPhaseOne(proposedIndex, majority);
                    if(performPhaseTwo(proposedIndex, writeVal, majority, acceptingChannels)) {
                        procide = true;
                    }
                    
                }
                result = true;
            }
        }

		if(result) {
			paxosManager.getPaxosInstance(proposedIndex).setAcceptedTimestamp(this.currentTimestamp);
			paxosManager.getPaxosInstance(proposedIndex).setAcceptedValue(writeVal);
		}
		return result;
	}

	// Perform Phase 2 of Paxos protocol (Accept phase)
	private boolean performCommitPhase(DadkvsMain.CommitRequest request, int majority, int timestamp) {

		int acceptCountCommit = 1; // Include leader
		int rejectCountCommit = 0;

        ArrayList<DadkvsMain.SequenceAck> sequence_responses = new ArrayList<DadkvsMain.SequenceAck>();
	    GenericResponseCollector<DadkvsMain.SequenceAck> sequence_collector = new GenericResponseCollector<DadkvsMain.SequenceAck> (sequence_responses, server_state.n_servers);

        DadkvsMain.SequencedRequest sequencedRequest = createSequencedRequest(request, timestamp );

		for (ManagedChannel channel : server_state.followerChannels) {
            CollectorStreamObserver<DadkvsMain.SequenceAck> sequence_observer = new CollectorStreamObserver<>(sequence_collector);

			DadkvsMainServiceGrpc.DadkvsMainServiceStub stub =
					DadkvsMainServiceGrpc.newStub(channel);


			try {
                stub.sequenceCommit(sequencedRequest, sequence_observer);

			} catch (Exception e) {
				System.err.println(
						"Error during commit request to follower: " + e.getMessage());

			}
		}

        sequence_collector.waitForTarget(server_state.followerChannels.size());
         if(sequence_responses.size() == server_state.followerChannels.size()) {
             Iterator<DadkvsMain.SequenceAck> sequence_iterator = sequence_responses.iterator();
             while(sequence_iterator.hasNext()) {
                 DadkvsMain.SequenceAck sequence_reply = sequence_iterator.next ();
                if (sequence_reply.getAccepted()) {
                    acceptCountCommit++;
                }
             }
        }

		return acceptCountCommit >= majority;
	}

    private DadkvsMain.SequencedRequest createSequencedRequest(DadkvsMain.CommitRequest commitRequest, int timestamp) {
        return DadkvsMain.SequencedRequest.newBuilder()
                .setCommit(commitRequest)
                .setTimestamp(timestamp)
                .build();
    }
	
	// Create Phase 2 request for Paxos protocol
	private DadkvsPaxos.PhaseTwoRequest createPhaseTwoRequest(int proposedIndex, int writeVal) {
		int proposalTimestamp = currentTimestamp;
		return DadkvsPaxos.PhaseTwoRequest.newBuilder()
			.setPhase2Config(0)
			.setPhase2Index(proposedIndex)
			.setPhase2Value(writeVal)
			.setPhase2Timestamp(proposalTimestamp)
			.build();
	}
	
	// Process commit and send learn request to followers
	private void processAndCommitTransaction(int proposedIndex, DadkvsMain.CommitRequest request,
			StreamObserver<DadkvsMain.CommitReply> responseObserver, int majority, int timestamp, List<ManagedChannel> acceptorsChannels) {

		System.out.println("Majority accepted Phase 2. Proceeding to learning.");
	
		sendLearnRequests(proposedIndex, request.getWriteval());

		paxosManager.getPaxosInstance(proposedIndex).setRequest(request);
		paxosManager.getPaxosInstance(proposedIndex).setObserver(responseObserver);
		paxosManager.getPaxosInstance(proposedIndex).setReadyToCommit(true);

	}

	public boolean doCommit (int proposedIndex, DadkvsMain.CommitRequest request,
	StreamObserver<DadkvsMain.CommitReply> responseObserver, int majority, int timestamp) {
		boolean result = false;

		if (processCommit(request, timestamp) && performCommitPhase(request, majority, timestamp)) {
			System.out.println("Transaction committed.");
			sendCommitResponse(responseObserver, request, true);
            paxosManager.getPaxosInstance(proposedIndex).setCommited(true);
			paxosManager.removeInstance(proposedIndex);
			result = true;
		} else {
			sendRejection(responseObserver, request, "Commit not accepted by majority.");
		}

		System.out.println(result?"TRUE" : "FALSE");

		return result;
	}
	
	// Send learn requests to followers after Phase 2
	private void sendLearnRequests(int proposedIndex, int writeVal) {
		DadkvsPaxos.LearnRequest learnRequest = createLearnRequest(proposedIndex, writeVal);
	
        ArrayList<DadkvsPaxos.LearnReply> learn_responses = new ArrayList<DadkvsPaxos.LearnReply>();
	    GenericResponseCollector<DadkvsPaxos.LearnReply> learn_collector = new GenericResponseCollector<DadkvsPaxos.LearnReply> (learn_responses, server_state.n_servers);

		for (ManagedChannel channel : server_state.followerChannels) {
            CollectorStreamObserver<DadkvsPaxos.LearnReply> learn_observer = new CollectorStreamObserver<>(learn_collector);

			DadkvsPaxosServiceGrpc.DadkvsPaxosServiceStub stub =
					DadkvsPaxosServiceGrpc.newStub(channel);

			try {
				stub.learn(learnRequest, learn_observer);
				System.out.println("Sent learn request to follower for index: " + proposedIndex);
			} catch (Exception e) {
				System.err.println("Error during learn request: " + e.getMessage());
			}
		}

        learn_collector.waitForTarget(server_state.followerChannels.size());
	}
	
	// Create learn request for Paxos protocol
	private DadkvsPaxos.LearnRequest createLearnRequest(int proposedIndex, int writeVal) {
		return DadkvsPaxos.LearnRequest.newBuilder()
			.setLearnconfig(0)
			.setLearnindex(proposedIndex)
			.setLearntimestamp(this.timestamp + 1)
			.setLearnvalue(writeVal)
			.build();
	}
	
	// Send the final commit response to the client
	private void sendCommitResponse(StreamObserver<DadkvsMain.CommitReply> responseObserver,
			DadkvsMain.CommitRequest request, boolean result) {

		DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
			.setReqid(request.getReqid())
			.setAck(result)
			.build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}
	
	// Send rejection response to the client
	private void sendRejection(StreamObserver<DadkvsMain.CommitReply> responseObserver,
			DadkvsMain.CommitRequest request, String reason) {

		System.out.println("Rejecting commit request: " + reason);
		DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
			.setReqid(request.getReqid())
			.setAck(false) // Reject
			.build();
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	// Follower processes the sequenced request sent by the leader
	@Override
	public void sequenceCommit(DadkvsMain.SequencedRequest request,
			StreamObserver<DadkvsMain.SequenceAck> responseObserver) {

		checkFreeze();
		
		//System.out.println("Follower received sequence request: " + request.getSequenceNumber());

		// Process the commit request (assume it is accepted for simplicity)
		boolean accepted = processCommit(request.getCommit(), request.getTimestamp()); // Apply the commit in sequence
		paxosManager.getPaxosInstance(this.paxosIndex).setCommited(true);
		paxosManager.incrementCommitedIndex();
		// Respond to the leader with an acknowledgment
		DadkvsMain.SequenceAck ack = DadkvsMain.SequenceAck.newBuilder()
				.setSequenceNumber(this.paxosIndex)
				.setAccepted(accepted)
				.build();

		responseObserver.onNext(ack);
		responseObserver.onCompleted();
	}

	/**
	 * Helper function to process commit requests. This function is used by both the leader and followers.
	 * 
	 * @param request CommitRequest containing the transaction information
	 * @return boolean indicating whether the commit was successful or not
	 */
	private boolean processCommit(DadkvsMain.CommitRequest request, int processTimestamp) {
		checkFreeze();
		
		int key1 = request.getKey1();
		int version1 = request.getVersion1();
		int key2 = request.getKey2();
		int version2 = request.getVersion2();
		int writekey = request.getWritekey();
		int writeval = request.getWriteval();

        System.out.println("AQUIIIIII 222222" + currentTimestamp);
		// Increment timestamp for the commit
		this.timestamp = processTimestamp;

		// Create a transaction record with the provided information
		TransactionRecord txrecord = new TransactionRecord(
				key1,
				version1,
				key2,
				version2,
				writekey,
				writeval,
				this.timestamp
			);

		// Attempt to commit the transaction in the key-value store
		return this.server_state.store.commit(txrecord);
	}

	// End of committx helper functions


	// Add an override for `executeDebugMode` to handle unfreezing
	public void executeDebugMode(DebugMode debugMode) {
		if (debugMode == DebugMode.UN_FREEZE) {
			unfreeze(); // Call unfreeze when the mode is set to UN_FREEZE
		}
	}
}
