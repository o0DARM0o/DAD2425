package dadkvs.server;

import java.util.concurrent.atomic.AtomicInteger;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import io.grpc.ManagedChannel;
import io.grpc.stub.StreamObserver;

public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

    DadkvsServerState server_state;
    int               timestamp;
	AtomicInteger sequenceCounter = new AtomicInteger(0);
    
    public DadkvsMainServiceImpl(DadkvsServerState state) {
        this.server_state = state;
	this.timestamp = 0;
    }

    @Override
    public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {
	// for debug purposes
	System.out.println("Receiving read request:" + request);

	int reqid = request.getReqid();
	int key = request.getKey();
	VersionedValue vv = this.server_state.store.read(key);
	
	DadkvsMain.ReadReply response =DadkvsMain.ReadReply.newBuilder()
	    .setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();
	
	responseObserver.onNext(response);
	responseObserver.onCompleted();
    }

	@Override
    public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {
        // for debug purposes
        System.out.println("Receiving commit request: " + request);

        if (server_state.i_am_leader) {
            // Leader: assign a sequence number to this commit request
            int seqNumber = sequenceCounter.incrementAndGet();
            System.out.println("Leader assigned sequence number: " + seqNumber);

            // Create a sequenced request to send to followers
            DadkvsMain.SequencedRequest sequencedRequest = DadkvsMain.SequencedRequest.newBuilder()
                    .setSequenceNumber(seqNumber)
                    .setCommit(request)
                    .build();

            // Send sequenced request to all followers and collect their acknowledgments
            boolean allAccepted = true;
            for (ManagedChannel channel : server_state.followerChannels) {
                DadkvsMainServiceGrpc.DadkvsMainServiceBlockingStub stub = DadkvsMainServiceGrpc.newBlockingStub(channel);
                DadkvsMain.SequenceAck ack = stub.sequenceCommit(sequencedRequest);

                if (!ack.getAccepted()) {
                    allAccepted = false; // If any follower rejects the request, we abort
                }
                System.out.println("Follower response for sequence " + seqNumber + ": " + ack.getAccepted());
            }

            // Process the commit locally if all followers accepted it
            if (allAccepted) {
                boolean result = processCommit(request);
                DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
                        .setReqid(request.getReqid()).setAck(result).build();

                responseObserver.onNext(response);
                responseObserver.onCompleted();
            } else {
                // Abort the transaction if followers didn't accept
                DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
                        .setReqid(request.getReqid()).setAck(false).build();

                responseObserver.onNext(response);
                responseObserver.onCompleted();
            }
        } 
        // else {
		// 	System.out.println("AQUIIIII");
        //     // Followers reject direct commit requests, only leader should process commits
        //     DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
        //             .setReqid(request.getReqid()).setAck(false).build();

        //     responseObserver.onNext(response);
        //     responseObserver.onCompleted();
        // }
    }

    @Override
    public void sequenceCommit(DadkvsMain.SequencedRequest request, StreamObserver<DadkvsMain.SequenceAck> responseObserver) {
        // Follower processes the sequenced request sent by the leader
        System.out.println("Follower received sequence request: " + request.getSequenceNumber());

        // Process the commit request (assume it is accepted for simplicity)
        boolean accepted = processCommit(request.getCommit()); // Apply the commit in sequence

        // Respond to the leader with an acknowledgment
        DadkvsMain.SequenceAck ack = DadkvsMain.SequenceAck.newBuilder()
                .setSequenceNumber(request.getSequenceNumber())
                .setAccepted(accepted)
                .build();

        responseObserver.onNext(ack);
        responseObserver.onCompleted();
    }

    /**
     * Helper function to process commit requests. This function is used by both the leader and followers.
     * 
     * @param request CommitRequest containing the transaction information
     * @return boolean indicating whether the commit was successful or not
     */
    private boolean processCommit(DadkvsMain.CommitRequest request) {
        int key1 = request.getKey1();
        int version1 = request.getVersion1();
        int key2 = request.getKey2();
        int version2 = request.getVersion2();
        int writekey = request.getWritekey();
        int writeval = request.getWriteval();

        // Increment timestamp for the commit
        this.timestamp++;

        // Create a transaction record with the provided information
        TransactionRecord txrecord = new TransactionRecord(key1, version1, key2, version2, writekey, writeval, this.timestamp);

        // Attempt to commit the transaction in the key-value store
        return this.server_state.store.commit(txrecord);
    }
}
 