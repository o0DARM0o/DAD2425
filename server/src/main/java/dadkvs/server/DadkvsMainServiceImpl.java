package dadkvs.server;

/* these imported classes are generated by the contract */
import dadkvs.DadkvsMain;
import dadkvs.DadkvsMainServiceGrpc;
import dadkvs.DadkvsPaxos;
import dadkvs.DadkvsPaxosServiceGrpc;
import dadkvs.util.PaxosManager;
import io.grpc.ManagedChannel;
import io.grpc.stub.StreamObserver;

public class DadkvsMainServiceImpl extends DadkvsMainServiceGrpc.DadkvsMainServiceImplBase {

    DadkvsServerState server_state;
    int               timestamp;
	int sequenceCounter = 0;
    PaxosManager paxosManager;
    int paxosIndex;
    
    public DadkvsMainServiceImpl(DadkvsServerState state, PaxosManager paxosManager) {
        this.server_state = state;
	    this.timestamp = 0;
        this.paxosManager = paxosManager;
        this.paxosIndex = 0;
    }

    @Override
    public void read(DadkvsMain.ReadRequest request, StreamObserver<DadkvsMain.ReadReply> responseObserver) {
	// for debug purposes
	System.out.println("Receiving read request:" + request);

	int reqid = request.getReqid();
	int key = request.getKey();
	VersionedValue vv = this.server_state.store.read(key);
	
	DadkvsMain.ReadReply response =DadkvsMain.ReadReply.newBuilder()
	    .setReqid(reqid).setValue(vv.getValue()).setTimestamp(vv.getVersion()).build();
	
	responseObserver.onNext(response);
	responseObserver.onCompleted();
    }

    @Override
    public void committx(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.CommitReply> responseObserver) {
        System.out.println("Receiving commit request: " + request);

        int proposedIndex = ++sequenceCounter;
        int key = request.getWritekey();

        // Check if the proposed index is less than or equal to the promised index
        if (proposedIndex <= server_state.promisedIndex) {
            System.out.println("Rejecting commit request: proposed index " + proposedIndex + " is not greater than promised index " + server_state.promisedIndex);
            DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
                .setReqid(request.getReqid())
                .setAck(false) // Reject
                .build();
            responseObserver.onNext(response);
            responseObserver.onCompleted();
            return;
        }

        this.paxosIndex = proposedIndex; 
        int proposalTimestamp = this.timestamp + 1;
        System.out.println("Starting Paxos instance for proposed index: " + proposedIndex + " with timestamp: " + proposalTimestamp);

        paxosManager.startPaxosInstance(proposedIndex, key, proposalTimestamp, request.getWriteval());

        if (server_state.i_am_leader) {
            int totalServers = server_state.n_servers;
            int majority = (totalServers / 2) + 1;

            // Phase 1: Prepare
            System.out.println("Leader assigned Paxos Instance number: " + proposedIndex);
            DadkvsPaxos.PhaseOneRequest phaseOneRequest = DadkvsPaxos.PhaseOneRequest.newBuilder()
                .setPhase1Config(0)
                .setPhase1Index(proposedIndex)
                .setPhase1Timestamp(proposalTimestamp)
                .build();

            int acceptCountPhase1 = 1; // Include leader's own acceptance
            int rejectCountPhase1 = 0;

            for (ManagedChannel channel : server_state.followerChannels) {
                DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stub = DadkvsPaxosServiceGrpc.newBlockingStub(channel);
                DadkvsPaxos.PhaseOneReply ack;
                try {
                    ack = stub.phaseone(phaseOneRequest);
                } catch (Exception e) {
                    System.err.println("Error during Phase 1 request to follower: " + e.getMessage());
                    rejectCountPhase1++;
                    continue;
                }

                if (ack.getPhase1Accepted()) {
                    System.out.println("Follower accepted Phase 1 for index: " + proposedIndex);
                    acceptCountPhase1++;
                } else {
                    System.out.println("Follower rejected Phase 1 for index: " + proposedIndex);
                    rejectCountPhase1++;
                }
            }

            if (acceptCountPhase1 >= majority) {
                server_state.promisedIndex = proposedIndex;
                System.out.println("Majority accepted Phase 1. Proceeding to Phase 2.");

                // Phase 2: Accept
                DadkvsPaxos.PhaseTwoRequest phaseTwoRequest = DadkvsPaxos.PhaseTwoRequest.newBuilder()
                    .setPhase2Config(0)
                    .setPhase2Index(proposedIndex)
                    .setPhase2Value(request.getWriteval())
                    .setPhase2Timestamp(proposalTimestamp)
                    .build();

                int acceptCountPhase2 = 1; // Include leader's own acceptance
                int rejectCountPhase2 = 0;

                for (ManagedChannel channel : server_state.followerChannels) {
                    DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stub = DadkvsPaxosServiceGrpc.newBlockingStub(channel);
                    DadkvsPaxos.PhaseTwoReply ack;
                    try {
                        ack = stub.phasetwo(phaseTwoRequest);
                    } catch (Exception e) {
                        System.err.println("Error during Phase 2 request to follower: " + e.getMessage());
                        rejectCountPhase2++;
                        continue;
                    }

                    if (ack.getPhase2Accepted()) {
                        System.out.println("Follower accepted Phase 2 for index: " + proposedIndex);
                        acceptCountPhase2++;
                    } else {
                        System.out.println("Follower rejected Phase 2 for index: " + proposedIndex);
                        rejectCountPhase2++;
                    }
                }

                if (acceptCountPhase2 >= majority) {
                    System.out.println("Majority accepted Phase 2. Proceeding to learning.");

                    // Learning Phase
                    DadkvsPaxos.LearnRequest learnRequest = DadkvsPaxos.LearnRequest.newBuilder()
                        .setLearnconfig(0)
                        .setLearnindex(proposedIndex)
                        .setLearntimestamp(proposalTimestamp)
                        .setLearnvalue(request.getWriteval())
                        .build();

                    // Send learn requests to followers
                    for (ManagedChannel channel : server_state.followerChannels) {
                        DadkvsPaxosServiceGrpc.DadkvsPaxosServiceBlockingStub stub = DadkvsPaxosServiceGrpc.newBlockingStub(channel);
                        try {
                            stub.learn(learnRequest);
                            System.out.println("Sent learn request to follower for index: " + proposedIndex);
                        } catch (Exception e) {
                            System.err.println("Error during Learn request to follower: " + e.getMessage());
                        }
                    }

                    // Committing the transaction
                    boolean result = processCommit(request);

                    // Send commit to followers
                    int acceptCountCommit = 1; // Include leader
                    int rejectCountCommit = 0;

                    for (ManagedChannel channel : server_state.followerChannels) {
                        DadkvsMainServiceGrpc.DadkvsMainServiceBlockingStub stub = DadkvsMainServiceGrpc.newBlockingStub(channel);
                        DadkvsMain.SequenceAck ack;
                        try {
                            ack = stub.sequenceCommit(request);
                            if (ack.getAccepted()) {
                                acceptCountCommit++;
                            } else {
                                rejectCountCommit++;
                            }
                        } catch (Exception e) {
                            System.err.println("Error during commit request to follower: " + e.getMessage());
                            rejectCountCommit++;
                        }
                    }

                    if (acceptCountCommit >= majority) {
                        System.out.println("Majority accepted the commit. Transaction committed.");
                        DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
                            .setReqid(request.getReqid())
                            .setAck(result)
                            .build();

                        responseObserver.onNext(response);
                        responseObserver.onCompleted();
                    } else {
                        System.out.println("Rejecting commit request: Commit not accepted by majority.");
                        sendRejection(responseObserver, request);
                    }

                } else {
                    // If Phase 2 was not accepted by majority
                    System.out.println("Rejecting commit request: Phase 2 not accepted by majority.");
                    sendRejection(responseObserver, request);
                }
            } else {
                // If Phase 1 was not accepted by majority
                System.out.println("Rejecting commit request: Phase 1 not accepted by majority.");
                sendRejection(responseObserver, request);
            }
        } else {
            // If not the leader, reject the commit request
            System.out.println("Rejecting commit request: Not the leader.");
        }
    }

    
    private void sendRejection(StreamObserver<DadkvsMain.CommitReply> responseObserver, DadkvsMain.CommitRequest request) {
        DadkvsMain.CommitReply response = DadkvsMain.CommitReply.newBuilder()
            .setReqid(request.getReqid())
            .setAck(false) // Rejeita
            .build();
    
        responseObserver.onNext(response);
        responseObserver.onCompleted();
    }

    @Override
    public void sequenceCommit(DadkvsMain.CommitRequest request, StreamObserver<DadkvsMain.SequenceAck> responseObserver) {        // Follower processes the sequenced request sent by the leader
        
        // Process the commit request (assume it is accepted for simplicity)
        boolean accepted = processCommit(request); // Apply the commit in sequence

        // Respond to the leader with an acknowledgment
        DadkvsMain.SequenceAck ack = DadkvsMain.SequenceAck.newBuilder()
                .setSequenceNumber(this.paxosIndex)
                .setAccepted(accepted)
                .build();

        responseObserver.onNext(ack);
        responseObserver.onCompleted();
    }

    /**
     * Helper function to process commit requests. This function is used by both the leader and followers.
     * 
     * @param request CommitRequest containing the transaction information
     * @return boolean indicating whether the commit was successful or not
     */
    private boolean processCommit(DadkvsMain.CommitRequest request) {
        int key1 = request.getKey1();
        int version1 = request.getVersion1();
        int key2 = request.getKey2();
        int version2 = request.getVersion2();
        int writekey = request.getWritekey();
        int writeval = request.getWriteval();

        // Increment timestamp for the commit
        this.timestamp++;

        // Create a transaction record with the provided information
        TransactionRecord txrecord = new TransactionRecord(key1, version1, key2, version2, writekey, writeval, this.timestamp);

        // Attempt to commit the transaction in the key-value store
        return this.server_state.store.commit(txrecord);
    }
}
 